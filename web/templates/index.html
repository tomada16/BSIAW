<html>
<head>
    <meta charset="UTF-8">
    <title>Strona g≈Ç√≥wna</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
</head>
<body class="main-page">
    <div class="main-container">
        {% with messages = get_flashed_messages(with_categories=true) %}
          {% if messages %}
            <div class="flashes">
              {% for category, message in messages %}
                <div class="flash {{ category }}">{{ message }}</div>
              {% endfor %}
            </div>
          {% endif %}
        {% endwith %}

        <p>Tw√≥j klucz sesji siƒô wyczerpie po {{ session_timeout }} sekundach.
            Od≈õwie≈º, aby automatycznie siƒô wylogowaƒá po tym czasie.</p>
        <a href="/logout">Wyloguj siƒô</a>

        <br><br>

        <div class="chat-container">
            <!-- LEFT: Chat pane -->
            <div class="card chat-box">
                {% if selected_friend %}
                    <div class="chat-header">Chat with {{ selected_friend.email }}</div>
                    <div id="chat-messages" class="messages">
                    </div>

                    <form id="composer" class="composer">
                        <input id="message-input" type="text" maxlength="2000" autocomplete="off" placeholder="Napisz wiadomo≈õƒá..." />
                        <button type="submit">Wy≈õlij</button>
                    </form>

                    <!-- Socket.IO client (served by Flask-SocketIO) -->
                    <script src="{{ url_for('static', filename='socket.io.min.js') }}"></script>
                    <script>

                    const updateMessageTimers = () => {
                        document.querySelectorAll('.msg-timestamp').forEach((t) => {
                            const d = Date.parse(t.getAttribute('timestamp'));
                            const seconds = Math.floor((Date.now() - d) / 1000);
                            if (seconds < 60) {
                                t.textContent = `${seconds}s ago`;
                            } else if (seconds <= 60 * 30) {
                                t.textContent = `${Math.floor(seconds / 60)} min ago`
                            } else {
                                t.textContent = new Date(d).toLocaleTimeString();
                            }
                        });
                    }

                    (function() {
                        const friendId = {{ selected_friend.id }};
                        const myId = {{ current_user_id }};
                        const messagesEl = document.getElementById('chat-messages');
                        const form = document.getElementById('composer');
                        const input = document.getElementById('message-input');

                        const socket = io({ withCredentials: true, transports: ['websocket', 'polling'] });

                        function appendMessage(body, fromMe, timestamp) {
                            const row = document.createElement('div');
                            row.className = 'msg' + (fromMe ? ' me' : '');

                            const bubble = document.createElement('span');
                            bubble.className = 'bubble';
                            bubble.innerHTML = `
                                <span class="msg-body"></span><br>
                                <span class="msg-timestamp"></span>
                            `;

                            const messageContent = bubble.querySelector('.msg-body');
                            /* Never use innerHTML for this! */
                            messageContent.textContent = body;

                            const messageTimestamp = bubble.querySelector('.msg-timestamp');
                            /* Let's get cheeky here: we can add a 'Z' to the ISO timestamp, indicating
                               it's a UTC timestamp so second offsets are real. :) */
                            messageTimestamp.setAttribute('timestamp', timestamp + 'Z');
                            messageTimestamp.textContent = (new Date(timestamp)).toLocaleTimeString();

                            row.appendChild(bubble);
                            messagesEl.insertBefore(row, messagesEl.lastElementChild);
                            messagesEl.scrollTop = messagesEl.scrollHeight;
                        }

                        socket.on('connect', () => {
                            console.log('[ws] connected');
                            socket.emit('join', { friend_id: friendId });
                        });

                        socket.on('history', (payload) => {
                            console.log('[ws] history', payload);
                            messagesEl.innerHTML = `
                                <div class="msg-typing" style="display: none">{{ selected_friend.email }} is typing</div>
                            `;
                            for (const m of (payload.messages || [])) {
                                appendMessage(m.body, m.sender_id === myId, m.created_at);
                            }
                        });

                        socket.on('message', (m) => {
                            console.log('[ws] message', m);
                            const msgTyping = document.querySelector('.msg-typing');
                            msgTyping.style.display = 'none';
                            messagesEl.scrollTop = messagesEl.scrollHeight;
                            appendMessage(m.body, m.sender_id === myId, m.created_at);
                        });

                        let hideMessageTimeout = null;

                        socket.on('type_message', (m) => {
                            if (m.sender_id == myId) {
                                /* Don't do anything if we are the one typing the message. */
                                return;
                            }

                            const msgTyping = document.querySelector('.msg-typing');

                            messagesEl.scrollTop = messagesEl.scrollHeight;
                            msgTyping.style.display = 'block';

                            if (hideMessageTimeout !== null) {
                                clearTimeout(hideMessageTimeout);
                            }

                            hideMessageTimeout = setTimeout(() => {
                                msgTyping.style.display = 'none';
                                messagesEl.scrollTop = messagesEl.scrollHeight;
                            }, 5000);
                        });

                        input.addEventListener('input', (e) => {
                            socket.emit('type_message', { friend_id: friendId });
                        });

                        form.addEventListener('submit', (ev) => {
                            ev.preventDefault();
                            let text = input.value.trim();
                            if (!text) return;

                            const emojiTable = {
                                fire: 'üî•',
                                heart: '‚ù§Ô∏è',
                                smile: 'üòÑ',
                                thumbs_up: 'üëç',
                                star: '‚≠ê',
                                poop: 'üí©',
                                clap: 'üëè',
                                thinking: 'ü§î',
                                cry: 'üò¢',
                                wink: 'üòâ',
                                party: 'ü•≥',
                                ok: 'üëå',
                                ok_hand: 'üëå',
                                laughing: 'üòÇ',
                                cool: 'üòé',
                                eyes: 'üëÄ',
                                hug: 'ü§ó',
                                money: 'üí∞',
                                coffee: '‚òï',
                                skull: 'üíÄ',
                                speaking: 'üó£Ô∏è'
                            };

                            Object.keys(emojiTable).forEach((name) => {
                                text = text.replaceAll(`:${name}:`, emojiTable[name]);
                            });

                            socket.emit('send_message', { friend_id: friendId, body: text });
                            input.value = '';
                        });
                    })();

                    setInterval(updateMessageTimers, 1000);
                    </script>

                {% else %}
                    <div class="muted">Select a friend on the right to open the chat here.</div>
                {% endif %}
            </div>

            <!-- RIGHT: Friends list -->
            <div class="card">
                <h3 class="friends-header">Przyjaciele</h3>
                {% if friends and friends|length > 0 %}
                <table class="friends-table">
                    <tr><th>Email</th></tr>
                    {% for fid, email in friends %}
                    <tr>
                        <td>
                            <a href="{{ url_for('chat', friend_id=fid) }}">{{ email }}</a>
                        </td>
                    </tr>
                    {% endfor %}
                </table>
                {% else %}
                    <p class="muted">Brak znajomych do wy≈õwietlenia.</p>
                {% endif %}
            </div>
        </div>
    </div>
</body>
</html>
